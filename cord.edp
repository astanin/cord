// Basic model of cord growth (oxygen-limited metabolism)
// FreeFEM++ version (P1 elements, SUPG for level set advection)
// 
// Sergey Astanin, 2008
// http://code.google.com/p/cord/

real mu=0.02; // cell motility
real phi0=0.75; // stress-free phi
real theta=0.15; // survival ATP production level
real alpha=200; // consumption rate

int N=50; // points per domain side
real dt=0.5; // time step
real T=200.0; // evaluate solution until t=T
int plotevery=10; // save solution every plotevery time steps
real R0=0.2; // initial radius of the tumour

real reinitPeriod=10.0; // how often re-initialize level set function
real reinitDt=0.1*dt; // level set re-initialization time step
real epsLS=0.01; // level set function regularization parameter
int maxiter=100; // maximum number of iterations in level set re-init procedure
real maxresidual=5e-2; // accuracy of the level set re-init procedure

func real Sigma(real phi) {
	return phi-phi0;
}

func real dSigma(real phi) {
	return 1.0;
}

func real Dphi(real phi) {
	return mu*phi*(Sigma(phi)+phi*dSigma(phi));
}

func real H(real u) {
	if (u > 0) {
		return 1.0;
	} else if (u < 0) {
		return 0.0;
	} else {
		return 0.5;
	}
}

// growth/death rate
func real Gamma(real phi, real c) {
	real atp=(1-phi)*c-theta;
	if (atp > 0) {
		return phi*atp;
	} else {
		return 0.8*phi*atp;
	}
}

// domain geometry
int South=100, East=101, North=102, West=103;

border south(t=0,1) {x=t; y=0; label=South;}
border east(t=0,1) {x=1; y=t; label=East;}
border north(t=0,1) {x=(1-t); y=1; label=North;}
border west(t=0,1) {x=0; y=(1-t); label=West;}

mesh Th=buildmesh(south(N)+east(N)+north(N)+west(N));
fespace Vh(Th,P1);

Vh ht=hTriangle;
real h=ht[].max;

// variables
Vh vh; // test function

Vh phi, oldphi; // cell volume fraction
phi=phi0;

Vh c; // oxygen concentration
c=1.0;

Vh psi, oldpsi; // level set functions (positive for tumour)
psi=1-sqrt((x*x+y*y)/(R0*R0));

Vh nabla2, S, nx, ny, residual; // temporary functions for level set re-init

Vh vx, vy;

problem phiEq(phi,vh,solver=CG) = int2d(Th)(phi*vh/dt
	+ Dphi(oldphi)*(dx(phi)*dx(vh)+dy(phi)*dy(vh))) // diffusion term
	- int2d(Th)(H(psi)*Gamma(oldphi,c)*vh) // growth term 
	- int2d(Th)(oldphi*vh/dt)
	+ on(North,phi=phi0);

problem cEq(c,vh,solver=CG) = int2d(Th)(dx(c)*dx(vh)+dy(c)*dy(vh)) // Laplace
	+ int2d(Th)(H(psi)*alpha*(1-phi)*c*vh) // consumption
	+ on(South,c=1.0);

// use SUPG method for psi level set advection
real pgtau=0.1; // test function bias factor
macro w(vh)((vh+pgtau*(vx*dx(vh)+vy*dy(vh)))) //; // biased test function
problem psiEqPG(psi,vh) = int2d(Th)(w(vh)*psi/dt)
	+ int2d(Th)(w(vh)*(vx*dx(psi)+vy*dy(psi)))
	- int2d(Th)(w(vh)*oldpsi/dt);

// to restore psi to signed distance
// iterate until steady state the solution of
// \partial_t \psi + \mathbf{w}(\psi) \cdot \nabla \psi = S(\psi_0)
// where
// 	S(\psi_0) = \frac{\psi_0}{\sqrt{\psi_0^2+\epsilon^2}}
// and
//	\mathbf{w}(\psi) = S(\psi_0) \nabla \psi / | \nabla \psi |
//
// This FreeFem++ code was partially borrowed from the reinitialization
// routines written by G. Allaire, B. Boutin, C. Dousset, O. Pantz.
// See: http://www.cmap.polytechnique.fr/~allaire/freefem_en.html
func bool reinitLS() {
	// nabla2=(grad(psi)^2)
	nabla2=(dx(psi))^2+(dy(psi))^2;
	// approximation of sign(psi)
	S=psi/(sqrt(psi^2+h*h*nabla2));
	residual=-S*(sqrt(nabla2)-1);
	int i=0;
	while (((residual[].max) > maxresidual) && (i<maxiter)) {
		// approximation of the normal
		nx=dx(psi)/(sqrt(nabla2+epsLS^2));
		ny=dy(psi)/(sqrt(nabla2+epsLS^2));
		// advect level set function
		oldpsi=psi;
		psi=convect([-S*nx,-S*ny],reinitDt,oldpsi);
		psi=psi+reinitDt*S;
		// evaluate residual
		nabla2=(dx(psi))^2+(dy(psi))^2;
//		residual=-S*(sqrt(nabla2)-1);
		residual=psi-oldpsi;
		i=i+1;
	}
	cout << "reinitialized in " << i << " iterations, "
		<< "||residual||_max =" << residual[].max << "\n";
}


// print all mesh functions to gnuplot-compatible file
func bool save(real t) {
	string name="mesh_" + t + ".gp";
	ofstream file(name);
	for (real xx=0; xx<=1.0+1.0/(N); xx+=1.0/(N)) {
		for (real yy=0; yy<=1.0+1.0/N; yy+=1.0/N) {
			file << xx << " " << yy << " "
				<< c(xx,yy) << " "
				<< phi(xx,yy) << " "
				<< psi(xx,yy) <<
				endl;
		}
		file << endl;
	}
	return true;
}

int i=0; // time steps after the last save
save(0.0);
reinitLS(); // reinitialize
real lastReinit=0;
for (real t=0; t<=T; t+=dt) {
	cout <<  "t=" << t << "\n";
	// phi step
	oldphi=phi;
	phiEq;
	// c step
	cEq;
	// interpolate velocity field
	vx=-mu*(Sigma(phi)+phi*dSigma(phi))*dx(phi);
	vy=-mu*(Sigma(phi)+phi*dSigma(phi))*dy(phi);
	// advect level set function
	oldpsi=psi;
	psiEqPG;
// or	psi=convect([-vx,-vy],dt,oldpsi);
	if ((t-lastReinit) >= reinitPeriod) {
		reinitLS();
		lastReinit=t;
	}
	// output
	if ((i>0) && (i >= (plotevery-1))) {
		save(t);
		i=0;
	}
	i++;
}
save(T);
